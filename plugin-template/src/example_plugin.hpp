#pragma once

// Include Forma core headers
#include <forma/core/ir.hpp>
#include <forma/core/forma.hpp>

namespace forma::example {

/**
 * Example plugin demonstrating the plugin architecture
 * 
 * This plugin processes Forma IR and generates output.
 * Modify this template for your specific use case.
 */
template<size_t MaxOutput = 4096>
class ExamplePlugin {
public:
    constexpr ExamplePlugin() : output_size(0) {
        output_buffer[0] = '\0';
    }
    
    /**
     * Process a Forma document and generate output
     * 
     * @param document The parsed Forma IR document
     */
    template<size_t MaxEnums, size_t MaxTypes, size_t MaxEvents, 
             size_t MaxInstances, size_t MaxTypeInstances>
    constexpr void process(const Document<MaxEnums, MaxTypes, MaxEvents, 
                                         MaxInstances, MaxTypeInstances>& document) {
        append_line("// Generated by Forma Example Plugin");
        append_line("");
        
        // Process enums
        for (size_t i = 0; i < document.enum_count; ++i) {
            process_enum(document.enums[i]);
        }
        
        // Process types
        for (size_t i = 0; i < document.type_count; ++i) {
            process_type(document.types[i]);
        }
        
        // Process instances
        for (size_t i = 0; i < document.instances.count(); ++i) {
            process_instance(document.instances.get(i));
        }
    }
    
    /**
     * Get the generated output as C string
     */
    constexpr const char* c_str() const {
        return output_buffer;
    }
    
    /**
     * Get the generated output as string_view
     */
    constexpr std::string_view get_output() const {
        return std::string_view(output_buffer, output_size);
    }
    
private:
    char output_buffer[MaxOutput];
    size_t output_size;
    
    constexpr void process_enum(const EnumDecl& enum_decl) {
        append("enum ");
        append(enum_decl.name);
        append_line(" {");
        
        for (size_t i = 0; i < enum_decl.value_count; ++i) {
            append("    ");
            append(enum_decl.values[i]);
            if (i < enum_decl.value_count - 1) {
                append(",");
            }
            append_line("");
        }
        
        append_line("};");
        append_line("");
    }
    
    constexpr void process_type(const TypeDecl& type_decl) {
        append("// Type: ");
        append(type_decl.name);
        append_line("");
    }
    
    constexpr void process_instance(const InstanceDecl& inst) {
        append("// Instance of type: ");
        append(inst.type_name);
        append_line("");
    }
    
    constexpr void append(const char* str) {
        while (*str && output_size < MaxOutput - 1) {
            output_buffer[output_size++] = *str++;
        }
        output_buffer[output_size] = '\0';
    }
    
    constexpr void append_line(const char* str) {
        append(str);
        if (output_size < MaxOutput - 1) {
            output_buffer[output_size++] = '\n';
            output_buffer[output_size] = '\0';
        }
    }
};

} // namespace forma::example
