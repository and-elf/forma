#pragma once

#include <string>
#include <vector>
#include <fstream>
#include <filesystem>
#include <iostream>
#include <cstdlib>

namespace forma::commands {

struct InitOptions {
    std::string project_name = "myapp";
    std::string build_system = "cmake";
    std::string target_triple;  // e.g., "aarch64-linux-gnu" for cross-compilation
    std::string renderer = "lvgl";
    std::string project_dir = ".";
    bool verbose = false;
};

// Generate a default forma.toml for a new project
std::string generate_project_toml(const InitOptions& opts) {
    std::string toml;
    
    toml += "# Forma Project Configuration\n";
    toml += "# Generated by 'forma init'\n\n";
    
    toml += "[package]\n";
    toml += "name = \"" + opts.project_name + "\"\n";
    toml += "version = \"0.1.0\"\n";
    toml += "description = \"A Forma application\"\n";
    toml += "authors = [\"Your Name\"]\n";
    toml += "license = \"MIT\"\n\n";
    
    toml += "[imports]\n";
    toml += "# Import search paths for .fml modules\n";
    toml += "paths = [\"./lib\", \"./lib/forma\"]\n\n";
    
    toml += "[build]\n";
    toml += "# Build system\n";
    toml += "system = \"" + opts.build_system + "\"\n\n";
    
    toml += "# C++ standard version\n";
    toml += "standard = \"c++20\"\n\n";
    
    toml += "# Compiler settings\n";
    toml += "warnings = true\n";
    toml += "warnings-as-errors = false\n";
    toml += "optimize = true\n\n";
    
    toml += "# Output settings\n";
    toml += "binary-name = \"" + opts.project_name + "\"\n\n";
    
    if (!opts.target_triple.empty()) {
        toml += "# Cross-compilation target\n";
        toml += "target = \"" + opts.target_triple + "\"\n\n";
    }
    
    toml += "[renderer]\n";
    toml += "# Rendering backend\n";
    toml += "backend = \"" + opts.renderer + "\"\n\n";
    
    toml += "[lsp]\n";
    toml += "# Language Server Protocol settings\n";
    toml += "enabled = true\n";
    toml += "diagnostics = true\n";
    toml += "completion = false\n";
    toml += "hover = false\n";
    toml += "goto-definition = true\n\n";
    
    toml += "[plugins]\n";
    toml += "# Plugin system settings\n";
    toml += "enabled = true\n";
    toml += "directory = \"./plugins\"\n";
    toml += "auto-load = false\n\n";
    
    toml += "[features]\n";
    toml += "# Language features\n";
    toml += "constexpr-evaluation = true\n";
    toml += "generic-types = true\n\n";
    
    return toml;
}

// Generate a basic main.forma file
std::string generate_main_forma(const InitOptions& opts) {
    std::string forma;
    
    forma += "// " + opts.project_name + " - Main Application\n\n";
    
    if (opts.renderer == "lvgl") {
        forma += "import forma.widgets\n";
        forma += "import forma.layout\n\n";
        
        forma += "App {\n";
        forma += "    title: \"" + opts.project_name + "\"\n";
        forma += "    width: 800\n";
        forma += "    height: 600\n\n";
        
        forma += "    Column {\n";
        forma += "        alignment: \"center\"\n";
        forma += "        spacing: 20\n\n";
        
        forma += "        Text {\n";
        forma += "            content: \"Hello, Forma!\"\n";
        forma += "            size: 24\n";
        forma += "            bold: true\n";
        forma += "        }\n\n";
        
        forma += "        Button {\n";
        forma += "            text: \"Click Me\"\n";
        forma += "            width: 200\n";
        forma += "            height: 50\n\n";
        
        forma += "            onClick: {\n";
        forma += "                // Handle button click\n";
        forma += "                print(\"Button clicked!\")\n";
        forma += "            }\n";
        forma += "        }\n";
        forma += "    }\n";
        forma += "}\n";
    } else {
        forma += "App {\n";
        forma += "    title: \"" + opts.project_name + "\"\n";
        forma += "}\n";
    }
    
    return forma;
}

// Download CMake if needed (using the cmake_downloader utility)
bool ensure_cmake_available(bool verbose) {
    if (verbose) {
        std::cout << "Checking for CMake..." << std::endl;
    }
    
    // Check if cmake is on PATH
    int result = system("cmake --version > /dev/null 2>&1");
    if (result == 0) {
        if (verbose) {
            std::cout << "✓ CMake found on system PATH" << std::endl;
        }
        return true;
    }
    
    if (verbose) {
        std::cout << "CMake not found. Auto-download is available via the cmake-generator plugin." << std::endl;
        std::cout << "You can install CMake manually or it will be downloaded when building." << std::endl;
    }
    
    return true; // Not a fatal error - will download during build
}

// Download cross-compiler if target specified
bool ensure_toolchain_available(const std::string& target, bool verbose) {
    if (target.empty()) {
        return true; // No cross-compilation
    }
    
    if (verbose) {
        std::cout << "Checking for " << target << " toolchain..." << std::endl;
    }
    
    // Try common compiler names for the target
    std::vector<std::string> compiler_checks;
    
    if (target.find("aarch64") != std::string::npos) {
        compiler_checks.push_back("aarch64-linux-gnu-gcc --version > /dev/null 2>&1");
        compiler_checks.push_back("aarch64-none-linux-gnu-gcc --version > /dev/null 2>&1");
    } else if (target.find("arm") != std::string::npos) {
        compiler_checks.push_back("arm-linux-gnueabihf-gcc --version > /dev/null 2>&1");
        compiler_checks.push_back("arm-none-linux-gnueabihf-gcc --version > /dev/null 2>&1");
    } else if (target.find("mingw") != std::string::npos) {
        compiler_checks.push_back("x86_64-w64-mingw32-gcc --version > /dev/null 2>&1");
    } else if (target.find("riscv") != std::string::npos) {
        compiler_checks.push_back("riscv64-unknown-linux-gnu-gcc --version > /dev/null 2>&1");
    }
    
    // Check if any compiler is available
    for (const auto& check : compiler_checks) {
        if (system(check.c_str()) == 0) {
            if (verbose) {
                std::cout << "✓ Toolchain for " << target << " found on system" << std::endl;
            }
            return true;
        }
    }
    
    if (verbose) {
        std::cout << "Toolchain for " << target << " not found." << std::endl;
        std::cout << "It will be downloaded automatically when building." << std::endl;
        std::cout << "Supported targets: aarch64-linux-gnu, arm-linux-gnueabihf, x86_64-w64-mingw32, riscv64-linux-gnu" << std::endl;
    }
    
    return true; // Not fatal - will download during build
}

// Create directory structure for new project
bool create_project_structure(const InitOptions& opts) {
    namespace fs = std::filesystem;
    
    try {
        // Create main project directory
        if (opts.project_dir != ".") {
            fs::create_directories(opts.project_dir);
        }
        
        fs::path proj_path(opts.project_dir);
        
        // Create subdirectories
        fs::create_directories(proj_path / "src");
        fs::create_directories(proj_path / "lib");
        fs::create_directories(proj_path / "lib" / "forma");
        fs::create_directories(proj_path / "build");
        fs::create_directories(proj_path / "assets");
        
        if (opts.verbose) {
            std::cout << "✓ Created directory structure" << std::endl;
        }
        
        return true;
    } catch (const std::exception& e) {
        std::cerr << "Error creating project structure: " << e.what() << std::endl;
        return false;
    }
}

// Write project files
bool write_project_files(const InitOptions& opts) {
    namespace fs = std::filesystem;
    fs::path proj_path(opts.project_dir);
    
    try {
        // Write forma.toml
        std::ofstream toml_file(proj_path / "forma.toml");
        if (!toml_file) {
            std::cerr << "Error: Could not create forma.toml" << std::endl;
            return false;
        }
        toml_file << generate_project_toml(opts);
        toml_file.close();
        
        if (opts.verbose) {
            std::cout << "✓ Created forma.toml" << std::endl;
        }
        
        // Write main.forma
        std::ofstream main_file(proj_path / "src" / "main.forma");
        if (!main_file) {
            std::cerr << "Error: Could not create src/main.forma" << std::endl;
            return false;
        }
        main_file << generate_main_forma(opts);
        main_file.close();
        
        if (opts.verbose) {
            std::cout << "✓ Created src/main.forma" << std::endl;
        }
        
        // Write .gitignore
        std::ofstream gitignore(proj_path / ".gitignore");
        if (gitignore) {
            gitignore << "build/\n";
            gitignore << "*.o\n";
            gitignore << "*.so\n";
            gitignore << "*.a\n";
            gitignore << opts.project_name << "\n";
            gitignore << ".vscode/\n";
            gitignore << ".DS_Store\n";
            gitignore.close();
            
            if (opts.verbose) {
                std::cout << "✓ Created .gitignore" << std::endl;
            }
        }
        
        // Write README.md
        std::ofstream readme(proj_path / "README.md");
        if (readme) {
            readme << "# " << opts.project_name << "\n\n";
            readme << "A Forma application.\n\n";
            readme << "## Building\n\n";
            readme << "```bash\n";
            readme << "forma src/main.forma\n";
            readme << "```\n\n";
            readme << "## Configuration\n\n";
            readme << "See `forma.toml` for project settings.\n\n";
            
            if (!opts.target_triple.empty()) {
                readme << "## Cross-Compilation\n\n";
                readme << "This project is configured for cross-compilation to: `" << opts.target_triple << "`\n\n";
                readme << "The toolchain will be downloaded automatically on first build.\n\n";
            }
            
            readme.close();
            
            if (opts.verbose) {
                std::cout << "✓ Created README.md" << std::endl;
            }
        }
        
        return true;
    } catch (const std::exception& e) {
        std::cerr << "Error writing project files: " << e.what() << std::endl;
        return false;
    }
}

// Main init command implementation
int run_init_command(const InitOptions& opts) {
    std::cout << "Initializing Forma project: " << opts.project_name << std::endl;
    
    if (opts.verbose) {
        std::cout << "\nConfiguration:" << std::endl;
        std::cout << "  Name: " << opts.project_name << std::endl;
        std::cout << "  Build system: " << opts.build_system << std::endl;
        std::cout << "  Renderer: " << opts.renderer << std::endl;
        if (!opts.target_triple.empty()) {
            std::cout << "  Target: " << opts.target_triple << std::endl;
        }
        std::cout << "  Directory: " << opts.project_dir << std::endl;
        std::cout << std::endl;
    }
    
    // Create project structure
    if (!create_project_structure(opts)) {
        return 1;
    }
    
    // Write project files
    if (!write_project_files(opts)) {
        return 1;
    }
    
    // Check for build tools
    if (opts.build_system == "cmake") {
        ensure_cmake_available(opts.verbose);
    }
    
    // Check for cross-compilation toolchain
    if (!opts.target_triple.empty()) {
        ensure_toolchain_available(opts.target_triple, opts.verbose);
    }
    
    std::cout << "\n✓ Project initialized successfully!" << std::endl;
    std::cout << "\nNext steps:" << std::endl;
    
    if (opts.project_dir != ".") {
        std::cout << "  cd " << opts.project_dir << std::endl;
    }
    
    std::cout << "  forma src/main.forma" << std::endl;
    std::cout << "\nFor more information, see README.md" << std::endl;
    
    return 0;
}

} // namespace forma::commands
