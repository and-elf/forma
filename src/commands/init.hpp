#pragma once

#include <string>
#include <vector>
#include <fstream>
#include <filesystem>
#include <iostream>
#include <cstdlib>
#include <dlfcn.h>

namespace forma::commands {

struct InitOptions {
    std::string project_name = "myapp";
    std::string build_system = "cmake";
    std::string target_triple;  // e.g., "aarch64-linux-gnu" for cross-compilation
    std::string target;         // e.g., "esp32", "linux", "windows"
    std::string renderer = "lvgl";
    std::string project_dir = ".";
    bool verbose = false;
    bool is_plugin = false;     // true for 'forma init plugin'
    std::string plugin_type = "renderer";  // "renderer", "lsp", "build", etc.
};

// Generate a default forma.toml for a new project
std::string generate_project_toml(const InitOptions& opts) {
    std::string toml;
    
    toml += "# Forma Project Configuration\n";
    toml += "# Generated by 'forma init'\n\n";
    
    toml += "[package]\n";
    toml += "name = \"" + opts.project_name + "\"\n";
    toml += "version = \"0.1.0\"\n";
    toml += "description = \"A Forma application\"\n";
    toml += "authors = [\"Your Name\"]\n";
    toml += "license = \"MIT\"\n\n";
    
    toml += "[imports]\n";
    toml += "# Import search paths for .fml modules\n";
    toml += "paths = [\"./lib\", \"./lib/forma\"]\n\n";
    
    toml += "[build]\n";
    toml += "# Build system\n";
    toml += "system = \"" + opts.build_system + "\"\n";
    if (!opts.target.empty()) {
        toml += "target = \"" + opts.target + "\"\n";
    }
    toml += "\n";
    // Add ESP32-specific configuration if target is ESP32
    if (!opts.target.empty() && opts.target.find("esp32") == 0) {
        toml += "[esp32]\n";
        toml += "idf_version = \"v5.1\"\n";
        toml += "target = \"" + opts.target + "\"\n";
        toml += "auto_install = true\n";
        toml += "download_toolchain = true\n\n";
    }
    
    
    toml += "# C++ standard version\n";
    toml += "standard = \"c++20\"\n\n";
    
    toml += "# Compiler settings\n";
    toml += "warnings = true\n";
    toml += "warnings-as-errors = false\n";
    toml += "optimize = true\n\n";
    
    toml += "# Output settings\n";
    toml += "binary-name = \"" + opts.project_name + "\"\n\n";
    
    if (!opts.target_triple.empty()) {
        toml += "# Cross-compilation target\n";
        toml += "target = \"" + opts.target_triple + "\"\n\n";
    }
    
    toml += "[renderer]\n";
    toml += "# Rendering backend\n";
    toml += "backend = \"" + opts.renderer + "\"\n\n";
    
    toml += "[lsp]\n";
    toml += "# Language Server Protocol settings\n";
    toml += "enabled = true\n";
    toml += "diagnostics = true\n";
    toml += "completion = false\n";
    toml += "hover = false\n";
    toml += "goto-definition = true\n\n";
    
    toml += "[plugins]\n";
    toml += "# Plugin system settings\n";
    toml += "enabled = true\n";
    toml += "directory = \"./plugins\"\n";
    toml += "auto-load = false\n\n";
    
    toml += "[features]\n";
    toml += "# Language features\n";
    toml += "constexpr-evaluation = true\n";
    toml += "generic-types = true\n\n";
    
    return toml;
}

// Generate a basic main.forma file
std::string generate_main_forma(const InitOptions& opts) {
    std::string forma;
    
    forma += "// " + opts.project_name + " - Main Application\n\n";
    
    if (opts.renderer == "lvgl") {
        forma += "import forma.widgets\n";
        forma += "import forma.layout\n\n";
        
        forma += "App {\n";
        forma += "    title: \"" + opts.project_name + "\"\n";
        forma += "    width: 800\n";
        forma += "    height: 600\n\n";
        
        forma += "    Column {\n";
        forma += "        alignment: \"center\"\n";
        forma += "        spacing: 20\n\n";
        
        forma += "        Text {\n";
        forma += "            content: \"Hello, Forma!\"\n";
        forma += "            size: 24\n";
        forma += "            bold: true\n";
        forma += "        }\n\n";
        
        forma += "        Button {\n";
        forma += "            text: \"Click Me\"\n";
        forma += "            width: 200\n";
        forma += "            height: 50\n\n";
        
        forma += "            onClick: {\n";
        forma += "                // Handle button click\n";
        forma += "                print(\"Button clicked!\")\n";
        forma += "            }\n";
        forma += "        }\n";
        forma += "    }\n";
        forma += "}\n";
    } else {
        forma += "App {\n";
        forma += "    title: \"" + opts.project_name + "\"\n";
        forma += "}\n";
    }
    
    return forma;
}

// Download CMake if needed (using the cmake_downloader utility)
bool ensure_cmake_available(bool verbose) {
    if (verbose) {
        std::cout << "Checking for CMake..." << std::endl;
    }
    
    // Check if cmake is on PATH
    int result = system("cmake --version > /dev/null 2>&1");
    if (result == 0) {
        if (verbose) {
            std::cout << "✓ CMake found on system PATH" << std::endl;
        }
        return true;
    }
    
    if (verbose) {
        std::cout << "CMake not found. Auto-download is available via the cmake-generator plugin." << std::endl;
        std::cout << "You can install CMake manually or it will be downloaded when building." << std::endl;
    }
    
    return true; // Not a fatal error - will download during build
}

// Download cross-compiler if target specified
bool ensure_toolchain_available(const std::string& target, bool verbose) {
    if (target.empty()) {
        return true; // No cross-compilation
    }
    
    if (verbose) {
        std::cout << "Checking for " << target << " toolchain..." << std::endl;
    }
    
    // Try common compiler names for the target
    std::vector<std::string> compiler_checks;
    
    if (target.find("aarch64") != std::string::npos) {
        compiler_checks.push_back("aarch64-linux-gnu-gcc --version > /dev/null 2>&1");
        compiler_checks.push_back("aarch64-none-linux-gnu-gcc --version > /dev/null 2>&1");
    } else if (target.find("arm") != std::string::npos) {
        compiler_checks.push_back("arm-linux-gnueabihf-gcc --version > /dev/null 2>&1");
        compiler_checks.push_back("arm-none-linux-gnueabihf-gcc --version > /dev/null 2>&1");
    } else if (target.find("mingw") != std::string::npos) {
        compiler_checks.push_back("x86_64-w64-mingw32-gcc --version > /dev/null 2>&1");
    } else if (target.find("riscv") != std::string::npos) {
        compiler_checks.push_back("riscv64-unknown-linux-gnu-gcc --version > /dev/null 2>&1");
    }
    
    // Check if any compiler is available
    for (const auto& check : compiler_checks) {
        if (system(check.c_str()) == 0) {
            if (verbose) {
                std::cout << "✓ Toolchain for " << target << " found on system" << std::endl;
            }
            return true;
        }
    }
    
    if (verbose) {
        std::cout << "Toolchain for " << target << " not found." << std::endl;
        std::cout << "It will be downloaded automatically when building." << std::endl;
        std::cout << "Supported targets: aarch64-linux-gnu, arm-linux-gnueabihf, x86_64-w64-mingw32, riscv64-linux-gnu" << std::endl;
    }
    
    return true; // Not fatal - will download during build
}

// Create directory structure for new project
bool create_project_structure(const InitOptions& opts) {
    namespace fs = std::filesystem;
    
    try {
        // Create main project directory
        if (opts.project_dir != ".") {
            fs::create_directories(opts.project_dir);
        }
        
        fs::path proj_path(opts.project_dir);
        
        // Create subdirectories
        fs::create_directories(proj_path / "src");
        fs::create_directories(proj_path / "lib");
        fs::create_directories(proj_path / "lib" / "forma");
        fs::create_directories(proj_path / "build");
        fs::create_directories(proj_path / "assets");
        
        if (opts.verbose) {
            std::cout << "✓ Created directory structure" << std::endl;
        }
        
        return true;
    } catch (const std::exception& e) {
        std::cerr << "Error creating project structure: " << e.what() << std::endl;
        return false;
    }
}

// Write project files
bool write_project_files(const InitOptions& opts) {
    namespace fs = std::filesystem;
    fs::path proj_path(opts.project_dir);
    
    try {
        // Write forma.toml
        std::ofstream toml_file(proj_path / "forma.toml");
        if (!toml_file) {
            std::cerr << "Error: Could not create forma.toml" << std::endl;
            return false;
        }
        toml_file << generate_project_toml(opts);
        toml_file.close();
        
        if (opts.verbose) {
            std::cout << "✓ Created forma.toml" << std::endl;
        }
        
        // Write main.forma
        std::ofstream main_file(proj_path / "src" / "main.forma");
        if (!main_file) {
            std::cerr << "Error: Could not create src/main.forma" << std::endl;
            return false;
        }
        main_file << generate_main_forma(opts);
        main_file.close();
        
        if (opts.verbose) {
            std::cout << "✓ Created src/main.forma" << std::endl;
        }
        
        // Write .gitignore
        std::ofstream gitignore(proj_path / ".gitignore");
        if (gitignore) {
            gitignore << "build/\n";
            gitignore << "*.o\n";
            gitignore << "*.so\n";
            gitignore << "*.a\n";
            gitignore << opts.project_name << "\n";
            gitignore << ".vscode/\n";
            gitignore << ".DS_Store\n";
            gitignore.close();
            
            if (opts.verbose) {
                std::cout << "✓ Created .gitignore" << std::endl;
            }
        }
        
        // Write README.md
        std::ofstream readme(proj_path / "README.md");
        if (readme) {
            readme << "# " << opts.project_name << "\n\n";
            readme << "A Forma application.\n\n";
            readme << "## Building\n\n";
            readme << "```bash\n";
            readme << "forma src/main.forma\n";
            readme << "```\n\n";
            readme << "## Configuration\n\n";
            readme << "See `forma.toml` for project settings.\n\n";
            
            if (!opts.target_triple.empty()) {
                readme << "## Cross-Compilation\n\n";
                readme << "This project is configured for cross-compilation to: `" << opts.target_triple << "`\n\n";
                readme << "The toolchain will be downloaded automatically on first build.\n\n";
            }
            
            readme.close();
            
            if (opts.verbose) {
                std::cout << "✓ Created README.md" << std::endl;
            }
        }
        
        return true;
    } catch (const std::exception& e) {
        std::cerr << "Error writing project files: " << e.what() << std::endl;
        return false;
    }
}

// Main init command implementation
int run_init_command(const InitOptions& opts) {
    std::cout << "Initializing Forma project: " << opts.project_name << std::endl;
    
    if (opts.verbose) {
        std::cout << "\nConfiguration:" << std::endl;
        std::cout << "  Name: " << opts.project_name << std::endl;
        std::cout << "  Build system: " << opts.build_system << std::endl;
        std::cout << "  Renderer: " << opts.renderer << std::endl;
        if (!opts.target.empty()) {
            std::cout << "  Target: " << opts.target << std::endl;
        }
        if (!opts.target_triple.empty()) {
            std::cout << "  Target triple: " << opts.target_triple << std::endl;
        }
        std::cout << "  Directory: " << opts.project_dir << std::endl;
        std::cout << std::endl;
    }
    
    // Create project structure
    if (!create_project_structure(opts)) {
        return 1;
    }
    
    // Write project files
    if (!write_project_files(opts)) {
        return 1;
    }
    
    // Check for build tools
    if (opts.build_system == "cmake") {
        ensure_cmake_available(opts.verbose);
    }
    
    // Handle ESP32 target setup
    if (!opts.target.empty() && opts.target.find("esp32") == 0) {
        std::cout << "\n" << "Setting up ESP32 target..." << std::endl;
        
        // Call ESP32 plugin setup
        std::string plugin_path = "plugins/esp32-lvgl/build/forma-esp32-lvgl.so";
        if (!std::filesystem::exists(plugin_path)) {
            plugin_path = "build/plugins/esp32-lvgl/forma-esp32-lvgl.so";
        }
        
        if (std::filesystem::exists(plugin_path)) {
            // Load and call ESP32 setup
            void* handle = dlopen(plugin_path.c_str(), RTLD_LAZY);
            if (handle) {
                typedef bool (*SetupESP32Fn)(const char*, const char*);
                auto setup_esp32 = (SetupESP32Fn)dlsym(handle, "setup_esp32_project");
                
                if (setup_esp32) {
                    std::string config_file = opts.project_dir + "/forma.toml";
                    setup_esp32(opts.project_dir.c_str(), config_file.c_str());
                }
                
                dlclose(handle);
            }
        } else {
            std::cout << "Note: ESP32 plugin not found. Project structure created," << std::endl;
            std::cout << "      but ESP-IDF setup skipped. Build the esp32-lvgl plugin" << std::endl;
            std::cout << "      and run 'forma init' again to complete ESP32 setup." << std::endl;
        }
    }
    
    // Check for cross-compilation toolchain
    if (!opts.target_triple.empty()) {
        ensure_toolchain_available(opts.target_triple, opts.verbose);
    }
    
    std::cout << "\n✓ Project initialized successfully!" << std::endl;
    std::cout << "\nNext steps:" << std::endl;
    
    if (opts.project_dir != ".") {
        std::cout << "  cd " << opts.project_dir << std::endl;
    }
    
    if (!opts.target.empty() && opts.target.find("esp32") == 0) {
        std::cout << "  source ~/esp/esp-idf/export.sh" << std::endl;
        std::cout << "  forma build" << std::endl;
        std::cout << "\nOr to build, flash, and monitor:" << std::endl;
        std::cout << "  idf.py build flash monitor" << std::endl;
    } else {
        std::cout << "  forma src/main.forma" << std::endl;
        std::cout << "  forma build" << std::endl;
    }
    
    std::cout << "\nFor more information, see README.md" << std::endl;
    
    return 0;
}

// ============================================================================
// Plugin Init - Minimal setup with just config and example code
// ============================================================================

std::string generate_plugin_toml(const std::string& name, const std::string& type) {
    std::string toml;
    toml += "[plugin]\n";
    toml += "name = \"" + name + "\"\n";
    toml += "version = \"0.1.0\"\n";
    toml += "type = \"" + type + "\"\n";
    toml += "description = \"" + name + " plugin for Forma\"\n\n";
    
    toml += "[api]\n";
    toml += "version = \"1.0.0\"\n\n";
    
    if (type == "renderer") {
        toml += "[renderer]\n";
        toml += "output_format = \"c\"\n";
        toml += "file_extension = \".c\"\n";
    }
    
    return toml;
}

std::string generate_plugin_source(const std::string& name, const std::string& type) {
    std::string src;
    src += "// " + name + " - Forma plugin\n\n";
    src += "#include <forma/core/ir.hpp>\n";
    src += "#include <string>\n\n";
    
    src += "extern \"C\" {\n\n";
    
    if (type == "renderer") {
        src += "const char* render(const char* forma_code) {\n";
        src += "    static std::string output;\n";
        src += "    output = \"// Generated by " + name + "\\n\";\n";
        src += "    output += forma_code;\n";
        src += "    return output.c_str();\n";
        src += "}\n\n";
    } else if (type == "build") {
        src += "bool generate_build_files(const char* project_dir) {\n";
        src += "    // Generate build files here\n";
        src += "    return true;\n";
        src += "}\n\n";
    } else {
        src += "bool process(const char* input) {\n";
        src += "    // Process input here\n";
        src += "    return true;\n";
        src += "}\n\n";
    }
    
    src += "const char* get_plugin_name() { return \"" + name + "\"; }\n";
    src += "const char* get_plugin_version() { return \"0.1.0\"; }\n";
    src += "const char* get_plugin_type() { return \"" + type + "\"; }\n\n";
    src += "} // extern \"C\"\n";
    
    return src;
}

int run_plugin_init(const InitOptions& opts) {
    namespace fs = std::filesystem;
    
    std::cout << "Initializing Forma plugin: " << opts.project_name << std::endl;
    
    // Create directory structure
    fs::path proj_path(opts.project_dir);
    fs::create_directories(proj_path / "src");
    fs::create_directories(proj_path / "examples");
    
    // Write plugin.toml
    std::ofstream toml(proj_path / "plugin.toml");
    toml << generate_plugin_toml(opts.project_name, opts.plugin_type);
    toml.close();
    
    // Write source
    std::ofstream src(proj_path / "src" / (opts.project_name + ".cpp"));
    src << generate_plugin_source(opts.project_name, opts.plugin_type);
    src.close();
    
    // Write README
    std::ofstream readme(proj_path / "README.md");
    readme << "# " << opts.project_name << " Plugin\n\n";
    readme << "A " << opts.plugin_type << " plugin for Forma.\n\n";
    readme << "## Files\n\n";
    readme << "- `plugin.toml` - Plugin configuration\n";
    readme << "- `src/" << opts.project_name << ".cpp` - Plugin implementation\n\n";
    readme << "## Building\n\n";
    readme << "Choose your build system and build as a shared library (.so/.dylib/.dll)\n";
    readme.close();
    
    // Write .gitignore
    std::ofstream gitignore(proj_path / ".gitignore");
    gitignore << "build/\n*.o\n*.so\n*.dylib\n*.dll\n";
    gitignore.close();
    
    std::cout << "\n✓ Plugin initialized!\n\n";
    std::cout << "Created files:\n";
    std::cout << "  plugin.toml\n";
    std::cout << "  src/" << opts.project_name << ".cpp\n";
    std::cout << "  README.md\n\n";
    std::cout << "Next: Set up your build system and compile as a shared library\n";
    
    return 0;
}

} // namespace forma::commands
