#pragma once

#include <string>
#include <vector>
#include <fstream>
#include <filesystem>
#include <iostream>
#include <sstream>
#include <cstdlib>

#include "core/fs/i_file_system.hpp"

namespace forma::commands {

struct InitOptions {
    std::string project_name = "myapp";
    std::string build_system = "cmake";
    std::string target_triple;  // e.g., "aarch64-linux-gnu" for cross-compilation
    std::string target;         // e.g., "esp32", "linux", "windows"
    std::string renderer = "lvgl";
    std::string project_dir = ".";
    bool verbose = false;
    bool is_plugin = false;     // true for 'forma init plugin'
    std::string plugin_type = "renderer";  // "renderer", "lsp", "build", etc.
};

// Generate a default forma.toml for a new project
std::string generate_project_toml(const InitOptions& opts) {
    std::ostringstream toml;
    
    toml << R"(# Forma Project Configuration
# Generated by 'forma init'

[package]
name = ")" << opts.project_name << R"("
version = "0.1.0"
description = "A Forma application"
authors = ["Your Name"]
license = "MIT"

[imports]
# Import search paths for .fml modules
paths = ["./lib", "./lib/forma"]

[build]
# Build system
system = ")" << opts.build_system << "\"\n";
    
    if (!opts.target.empty()) {
        toml << "target = \"" << opts.target << "\"\n";
    }
    toml << "\n";
    
    toml << R"(# C++ standard version
standard = "c++20"

# Compiler settings
warnings = true
warnings-as-errors = false
optimize = true

# Output settings
binary-name = ")" << opts.project_name << "\"\n";
    toml << "directory = \"build\"\n\n";
    
    if (!opts.target_triple.empty()) {
        toml << "# Cross-compilation target\n"
             << "target = \"" << opts.target_triple << "\"\n\n";
    }
    
    toml << R"([toolchains]
# Toolchain storage directory (relative to project root)
# Downloaded cross-compilers and toolchains are stored here
directory = ".forma/toolchains"
auto-download = true

[cache]
# Cache directory for downloads and temporary files
directory = ".forma/cache"

[renderer]
# Rendering backend
backend = ")" << opts.renderer << R"("

[lsp]
# Language Server Protocol settings
enabled = true
diagnostics = true
completion = false
hover = false
goto-definition = true

[plugins]
# Plugin system settings
# Specify paths to plugin shared libraries (.so/.dylib/.dll)
libraries = []

[features]
# Language features
constexpr-evaluation = true
generic-types = true

)";
    
    return toml.str();
}

// Generate a basic main.forma file
std::string generate_main_forma(const InitOptions& opts) {
    std::ostringstream forma;
    
    forma << "// " << opts.project_name << R"( - Main Application

App {
    title: ")" << opts.project_name << R"("
    width: 800
    height: 600
}
)";
    
    return forma.str();
}



bool create_project_structure(const InitOptions& opts, forma::fs::IFileSystem& fsys) {
    try {
        if (opts.project_dir != ".") {
            fsys.create_dirs(opts.project_dir);
        }

        fsys.create_dirs(opts.project_dir + "/src");
        fsys.create_dirs(opts.project_dir + "/lib");
        fsys.create_dirs(opts.project_dir + "/lib/forma");
        fsys.create_dirs(opts.project_dir + "/build");
        fsys.create_dirs(opts.project_dir + "/assets");

        if (opts.verbose) {
            std::cout << "✓ Created directory structure" << std::endl;
        }

        return true;
    } catch (const std::exception& e) {
        std::cerr << "Error creating project structure: " << e.what() << std::endl;
        return false;
    }
}

// Write project files
// Write project files using IFileSystem
bool write_project_files(const InitOptions& opts, forma::fs::IFileSystem& fsys) {
    try {
        // Write forma.toml
        fsys.write_file(opts.project_dir + "/forma.toml", generate_project_toml(opts));

        if (opts.verbose) {
            std::cout << "✓ Created forma.toml" << std::endl;
        }

        // Write main.forma
        fsys.write_file(opts.project_dir + "/src/main.forma", generate_main_forma(opts));

        if (opts.verbose) {
            std::cout << "✓ Created src/main.forma" << std::endl;
        }

        // Write .gitignore
        std::string gitignore = "build/\n*.o\n*.so\n*.a\n" + opts.project_name + "\n.vscode/\n.DS_Store\n";
        fsys.write_file(opts.project_dir + "/.gitignore", gitignore);

        if (opts.verbose) {
            std::cout << "✓ Created .gitignore" << std::endl;
        }

        // Write README.md
        std::ostringstream readme;
        readme << "# " << opts.project_name << "\n\n";
        readme << "A Forma application.\n\n";
        readme << "## Building\n\n";
        readme << "```bash\n";
        readme << "forma src/main.forma\n";
        readme << "```\n\n";
        readme << "## Configuration\n\n";
        readme << "See `forma.toml` for project settings.\n\n";

        if (!opts.target_triple.empty()) {
            readme << "## Cross-Compilation\n\n";
            readme << "This project is configured for cross-compilation to: `" << opts.target_triple << "`\n\n";
            readme << "The toolchain will be downloaded automatically on first build.\n\n";
        }

        fsys.write_file(opts.project_dir + "/README.md", readme.str());

        if (opts.verbose) {
            std::cout << "✓ Created README.md" << std::endl;
        }

        return true;
    } catch (const std::exception& e) {
        std::cerr << "Error writing project files: " << e.what() << std::endl;
        return false;
    }
}

// Main init command implementation
int run_init_command(const InitOptions& opts, forma::fs::IFileSystem& fsys);

int run_init_command(const InitOptions& opts) {
    forma::fs::RealFileSystem real;
    return run_init_command(opts, real);
}

int run_init_command(const InitOptions& opts, forma::fs::IFileSystem& fsys) {
    std::cout << "Initializing Forma project: " << opts.project_name << std::endl;

    if (opts.verbose) {
        std::cout << "\nConfiguration:" << std::endl;
        std::cout << "  Name: " << opts.project_name << std::endl;
        std::cout << "  Build system: " << opts.build_system << std::endl;
        std::cout << "  Renderer: " << opts.renderer << std::endl;
        if (!opts.target.empty()) {
            std::cout << "  Target: " << opts.target << std::endl;
        }
        if (!opts.target_triple.empty()) {
            std::cout << "  Target triple: " << opts.target_triple << std::endl;
        }
        std::cout << "  Directory: " << opts.project_dir << std::endl;
        std::cout << std::endl;
    }

    // Create project structure
    if (!create_project_structure(opts, fsys)) {
        return 1;
    }

    // Write project files
    if (!write_project_files(opts, fsys)) {
        return 1;
    }

    std::cout << "\n✓ Project initialized successfully!" << std::endl;
    std::cout << "\nNext steps:" << std::endl;

    if (opts.project_dir != ".") {
        std::cout << "  cd " << opts.project_dir << std::endl;
    }

    std::cout << "  forma build" << std::endl;
    std::cout << "\nFor more information, see README.md" << std::endl;

    return 0;
}

// ============================================================================
// Plugin Init - Minimal setup with just config and example code
// ============================================================================

std::string generate_plugin_toml(const std::string& name, const std::string& type) {
    std::ostringstream toml;
    
    toml << R"([plugin]
name = ")" << name << R"("
version = "0.1.0"
type = ")" << type << R"("
description = ")" << name << R"( plugin for Forma"

[api]
version = "1.0.0"

)";
    
    if (type == "renderer") {
        toml << R"([renderer]
output_format = "c"
file_extension = ".c"
)";
    }
    
    return toml.str();
}

std::string generate_plugin_source(const std::string& name, const std::string& type) {
    std::ostringstream src;
    
    src << "// " << name << R"( - Forma plugin

#include <forma/core/ir.hpp>
#include <string>

extern "C" {

)";
    
    if (type == "renderer") {
        src << "const char* render(const char* forma_code) {\n"
            << "    static std::string output;\n"
            << "    output = \"// Generated by " << name << "\\n\";\n"
            << "    output += forma_code;\n"
            << "    return output.c_str();\n"
            << "}\n\n";
    } else if (type == "build") {
        src << R"(bool generate_build_files(const char* project_dir) {
    // Generate build files here
    return true;
}

)";
    } else {
        src << R"(bool process(const char* input) {
    // Process input here
    return true;
}

)";
    }
    
    src << "const char* get_plugin_name() { return \"" << name << "\"; }\n"
        << "const char* get_plugin_version() { return \"0.1.0\"; }\n"
        << "const char* get_plugin_type() { return \"" << type << "\"; }\n\n"
        << "} // extern \"C\"\n";
    
    return src.str();
}

int run_plugin_init(const InitOptions& opts) {
    namespace fs = std::filesystem;
    
    std::cout << "Initializing Forma plugin: " << opts.project_name << std::endl;
    
    // Create directory structure
    fs::path proj_path(opts.project_dir);
    fs::create_directories(proj_path / "src");
    fs::create_directories(proj_path / "examples");
    
    // Write plugin.toml
    std::ofstream toml(proj_path / "plugin.toml");
    toml << generate_plugin_toml(opts.project_name, opts.plugin_type);
    toml.close();
    
    // Write source
    std::ofstream src(proj_path / "src" / (opts.project_name + ".cpp"));
    src << generate_plugin_source(opts.project_name, opts.plugin_type);
    src.close();
    
    // Write README
    std::ofstream readme(proj_path / "README.md");
    readme << "# " << opts.project_name << " Plugin\n\n";
    readme << "A " << opts.plugin_type << " plugin for Forma.\n\n";
    readme << "## Files\n\n";
    readme << "- `plugin.toml` - Plugin configuration\n";
    readme << "- `src/" << opts.project_name << ".cpp` - Plugin implementation\n\n";
    readme << "## Building\n\n";
    readme << "Choose your build system and build as a shared library (.so/.dylib/.dll)\n";
    readme.close();
    
    // Write .gitignore
    std::ofstream gitignore(proj_path / ".gitignore");
    gitignore << "build/\n*.o\n*.so\n*.dylib\n*.dll\n";
    gitignore.close();
    
    std::cout << "\n✓ Plugin initialized!\n\n";
    std::cout << "Created files:\n";
    std::cout << "  plugin.toml\n";
    std::cout << "  src/" << opts.project_name << ".cpp\n";
    std::cout << "  README.md\n\n";
    std::cout << "Next: Set up your build system and compile as a shared library\n";
    
    return 0;
}

} // namespace forma::commands
