# Plugin Development Guide

This guide explains how to create dynamic plugins for the Forma compiler.

## Overview

Forma supports two types of plugins:

1. **Header-Only Plugins** - Included at compile time (e.g., tracer, lvgl-renderer)
2. **Dynamic Plugins** - Loaded at runtime from shared libraries (.so files)

This guide focuses on dynamic plugins.

## Plugin Architecture

### Plugin Descriptor

Every plugin must define a `FormaPluginDescriptor`:

```cpp
struct FormaPluginDescriptor {
    uint32_t api_version;          // Must be 1
    const char* name;              // Plugin name (e.g., "my-plugin")
    const char* version;           // Semantic version (e.g., "1.0.0")
    PluginCapabilities capabilities;  // What the plugin provides
    void* register_plugin;         // Optional registration function
};
```

### Plugin Capabilities

```cpp
struct PluginCapabilities {
    bool supports_renderer;   // Code generation backend
    bool supports_theme;      // UI theming
    bool supports_audio;      // Audio processing
    bool supports_build;      // Build system integration
};
```

### Export Function

Plugins must export a C function named `forma_get_plugin_descriptor`:

```cpp
extern "C" {
    FormaPluginDescriptor* forma_get_plugin_descriptor();
}
```

## Creating a Plugin

### 1. Minimal Plugin Template

```cpp
// my_plugin.cpp
#include <cstdint>

extern "C" {

struct PluginCapabilities {
    bool supports_renderer;
    bool supports_theme;
    bool supports_audio;
    bool supports_build;
};

struct FormaPluginDescriptor {
    uint32_t api_version;
    const char* name;
    const char* version;
    PluginCapabilities capabilities;
    void* register_plugin;
};

static FormaPluginDescriptor my_plugin = {
    .api_version = 1,
    .name = "my-plugin",
    .version = "1.0.0",
    .capabilities = {
        .supports_renderer = false,
        .supports_theme = false,
        .supports_audio = false,
        .supports_build = false
    },
    .register_plugin = nullptr
};

FormaPluginDescriptor* forma_get_plugin_descriptor() {
    return &my_plugin;
}

} // extern "C"
```

### 2. Build the Plugin

```bash
g++ -std=c++20 -fPIC -shared -Wl,--export-dynamic my_plugin.cpp -o libmyplugin.so
```

**Flags explained:**
- `-std=c++20` - C++20 standard
- `-fPIC` - Position Independent Code (required for shared libraries)
- `-shared` - Create shared library
- `-Wl,--export-dynamic` - Export C symbols
- `-o libmyplugin.so` - Output filename

### 3. Use the Plugin

```bash
# List loaded plugins
./forma --plugin ./libmyplugin.so --list-plugins

# Use during compilation
./forma --plugin ./libmyplugin.so input.forma
```

## Advanced: Renderer Plugin

```cpp
// custom_renderer.cpp
#include <cstdint>
#include <iostream>

extern "C" {

// ... (plugin structures) ...

// Plugin initialization
FormaPluginDescriptor* forma_get_plugin_descriptor() {
    std::cout << "[Custom Renderer] Loading...\n";
    return &renderer_plugin;
}

// Renderer implementation
void render_code(const char* source) {
    std::cout << "// Generated by custom renderer\n";
    std::cout << source << "\n";
}

static FormaPluginDescriptor renderer_plugin = {
    .api_version = 1,
    .name = "custom-renderer",
    .version = "1.0.0",
    .capabilities = {
        .supports_renderer = true,
        .supports_theme = false,
        .supports_audio = false,
        .supports_build = false
    },
    .register_plugin = nullptr
};

} // extern "C"
```

## Plugin Loading Process

1. **Command Line**: User specifies `--plugin path/to/plugin.so`
2. **dlopen**: Forma loads the shared library
3. **dlsym**: Finds `forma_get_plugin_descriptor` symbol
4. **Call**: Invokes function to get descriptor
5. **Validate**: Checks API version compatibility
6. **Register**: Stores plugin for use during compilation

## Error Handling

### Common Errors

**"Cannot find forma_get_plugin_descriptor"**
- Ensure `extern "C"` is used
- Build with `-Wl,--export-dynamic`
- Verify symbol with: `nm -D libplugin.so | grep forma`

**"Incompatible API version"**
- Plugin api_version must be `1`
- Rebuild plugin with correct version

**"Failed to load plugin: ... cannot open shared object file"**
- Check file path is correct
- Ensure library has correct permissions
- Use absolute paths if relative paths fail

## Best Practices

1. **Version Checking**: Always set `api_version = 1`
2. **Static Descriptor**: Use static storage for descriptor
3. **C Linkage**: Always use `extern "C"` for export function
4. **Logging**: Print initialization messages for debugging
5. **Error Handling**: Return nullptr on initialization failure
6. **Memory Management**: Plugin stays loaded for program lifetime

## Plugin Directory Structure

```
plugins/my-plugin/
├── CMakeLists.txt         # Build configuration
├── README.md              # Plugin documentation
├── my_plugin.cpp          # Plugin implementation
├── tests/                 # Plugin tests
└── examples/              # Usage examples
```

## CMake Integration

```cmake
cmake_minimum_required(VERSION 3.15)
project(MyPlugin VERSION 1.0.0)

set(CMAKE_CXX_STANDARD 20)

add_library(myplugin SHARED my_plugin.cpp)
set_target_properties(myplugin PROPERTIES
    PREFIX "lib"
    SUFFIX ".so"
)

# Export symbols
target_link_options(myplugin PRIVATE -Wl,--export-dynamic)

install(TARGETS myplugin
    LIBRARY DESTINATION lib/forma/plugins
)
```

## Testing

```bash
# Build plugin
g++ -std=c++20 -fPIC -shared -Wl,--export-dynamic my_plugin.cpp -o libmyplugin.so

# Verify exported symbols
nm -D libmyplugin.so | grep forma

# Test loading
./forma --plugin ./libmyplugin.so --list-plugins

# Expected output:
# Loaded plugins:
#   - my-plugin v1.0.0
#     Path: ./libmyplugin.so
```

## Examples

See:
- `plugins/hello-world/` - Minimal example
- `plugins/lvgl-renderer/` - Header-only renderer (can be adapted to dynamic)
- `plugins/tracer/` - Header-only tooling plugin

## Troubleshooting

**Q: My plugin isn't loading**
- Check `nm -D libplugin.so` shows `forma_get_plugin_descriptor`
- Ensure file is readable: `chmod +r libplugin.so`
- Use verbose mode: `./forma -v --plugin ./libplugin.so`

**Q: Symbol not found**
- Must use `extern "C"` and `-Wl,--export-dynamic`
- Function name must be exactly `forma_get_plugin_descriptor`

**Q: Can I write plugins in C?**
- Yes! Use pure C and `extern "C"` is automatic

## Future Features

- [ ] Hot reloading of plugins
- [ ] Plugin dependency resolution
- [ ] Plugin configuration files
- [ ] Multiple plugins per .so file
- [ ] Plugin marketplace/registry
